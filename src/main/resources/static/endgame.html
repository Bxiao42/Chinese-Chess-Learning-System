<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Endgame Practice</title>
    <style>
        :root{ --cell:50px; }
        body{
            margin:0;
            padding:20px;
            display:flex;
            gap:80px;
            font-family:system-ui, sans-serif;
            background:#fafafb;
            justify-content: center;
        }
        #levelSelection{
            margin-bottom:20px;
            text-align:center;
        }
        .level-btn{
            padding:12px 20px;
            margin:5px;
            border-radius:8px;
            border:2px solid #000;
            background:#fff;
            cursor:pointer;
            font-size:16px;
            transition: all 0.2s ease;
        }
        .level-btn:hover{
            background:#f0f0f0;
            color:#000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .level-btn.completed{ background:#4CAF50; color:white; }
        .level-btn.current{ border-color:#FF9800; background:#FF9800; color:white; }

        #gameArea{
            display:none;
            width: 100%;
            max-width: 1200px;
        }
        #leftCol{
            display:flex;
            flex-direction:column;
            gap:15px;
            align-items:center;
            flex: 0 0 auto;
        }
        #board{
            border:1px solid #222;
            background:#fefefe;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .toolbar{
            display:flex;
            gap:8px;
            align-items:center;
            flex-wrap:wrap;
        }
        button{
            padding:8px 14px;
            border-radius:10px;
            border:1px solid #ddd;
            background:#fff;
            cursor:pointer;
            font-size:14px;
        }
        button:hover{
            box-shadow:0 4px 12px rgba(0,0,0,.08);
        }
        h3{
            margin:.2rem 0;
            color: #333;
        }
        table{
            border-collapse:collapse;
            background:#fff;
            border-radius:12px;
            overflow:hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        th,td{
            border:1px solid #eee;
            padding:8px 10px;
            font-size:14px;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        #foulTable{
            width:360px;
        }
        .hint{
            color:#888;
            font-size:12px;
        }
        #statusBar{
            margin:15px 0;
            padding:10px 12px;
            border:1px solid #e0e0e0;
            background:#f8f9fa;
            border-radius:8px;
            color:#444;
            min-height: 20px;
            font-weight: 500;
        }

        .game-over {
            background: #fff3cd !important;
            border-color: #ffeaa7 !important;
            color: #856404 !important;
            font-weight: bold !important;
        }

        .win-message {
            background: #d1ecf1 !important;
            border-color: #bee5eb !important;
            color: #0c5460 !important;
        }

        .lose-message {
            background: #f8d7da !important;
            border-color: #f5c6cb !important;
            color: #721c24 !important;
        }

        #rightCol {
            display: flex;
            flex-direction: column;
            gap: 25px;
            margin-left: 60px;
        }

        .game-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        /* Removed CSV download button related styles */
    </style>
</head>
<body>
<div id="levelSelection">
    <h2>Endgame Practice - Select Level</h2>
    <div id="levelButtons">
        <!-- Level buttons will be dynamically generated by JavaScript -->
    </div>
</div>

<div id="gameArea">
    <div class="game-container">
        <div id="leftCol">
            <canvas id="board" width="450" height="500"></canvas>
            <div class="toolbar">
                <button onclick="resetLevel()">Restart</button>
                <button onclick="backToLevels()">Back to Levels</button>
                <span class="hint">Red moves first: Click to select piece, then click target square</span>
            </div>
        </div>

        <div id="rightCol">
            <div id="statusBar">Status: In Progress</div>

            <h3>Foul Records</h3>
            <table id="foulTable">
                <tr><th>#</th><th>Type</th></tr>
            </table>

            <!-- Removed CSV download area -->
        </div>
    </div>
</div>

<script>
    /* ========== Canvas & DPR ========== */
    const cvs = document.getElementById('board');
    const ctx = cvs.getContext('2d');
    const DPR = window.devicePixelRatio || 1;
    const LOGICAL_W = 450, LOGICAL_H = 500;
    cvs.style.width  = LOGICAL_W + 'px';
    cvs.style.height = LOGICAL_H + 'px';
    cvs.width  = Math.round(LOGICAL_W * DPR);
    cvs.height = Math.round(LOGICAL_H * DPR);
    ctx.scale(DPR, DPR);

    /* ========== Fixed inner frame ========== */
    const PAD_L = 24, PAD_R = 24, PAD_T = 22, PAD_B = 22;

    /* ========== Geometry ========== */
    const OUT_W = LOGICAL_W, OUT_H = LOGICAL_H;
    const COLS = 9, ROWS = 10;
    const INNER_X = PAD_L;
    const INNER_Y = PAD_T;
    const INNER_W = OUT_W - PAD_L - PAD_R;
    const INNER_H = OUT_H - PAD_T - PAD_B;
    const CELL_W  = INNER_W / COLS;
    const CELL_H  = INNER_H / ROWS;

    /* ========== Resources & Game ========== */
    const RED='RED', BLACK='BLACK';
    const SPRITES = {
        board: '/images/MAIN.GIF',
        RR:'/images/RR.GIF', RN:'/images/RN.GIF', RB:'/images/RB.GIF',
        RA:'/images/RA.GIF', RK:'/images/RK.GIF', RC:'/images/RC.GIF', RP:'/images/RP.GIF',
        BR:'/images/BR.GIF', BN:'/images/BN.GIF', BB:'/images/BB.GIF',
        BA:'/images/BA.GIF', BK:'/images/BK.GIF', BC:'/images/BC.GIF', BP:'/images/BP.GIF',
    };
    const IMGS = {};

    // Endgame configuration cache
    const endgameConfigs = {};
    let currentLevel = 1;
    let board = Array.from({length:ROWS}, ()=>Array(COLS).fill(null));
    let select = null;
    let locked = false;
    let foulRows = [];

    /* ========== Initialization ========== */
    function loadImage(src){
        return new Promise(r=>{
            const i=new Image();
            i.onload=()=>r(i);
            i.onerror=()=>r(null);
            i.src=src;
        });
    }

    async function preload(){
        IMGS.board = await loadImage(SPRITES.board);
        await Promise.all(Object.keys(SPRITES).filter(k=>k!=='board').map(async k=>IMGS[k]=await loadImage(SPRITES[k])));
    }

    function imgKeyOf(piece){
        if(!piece) return null;
        const typeMap = {K:'K', A:'A', B:'B', N:'N', R:'R', C:'C', P:'P'};
        const sidePrefix = piece.s === RED ? 'R' : 'B';
        const typeChar = typeMap[piece.t];
        return sidePrefix + typeChar;
    }

    /* ========== Level Selection ========== */
    function initLevelSelection() {
        const container = document.getElementById('levelButtons');
        container.innerHTML = '';
        for(let i=1; i<=10; i++) {
            const btn = document.createElement('button');
            btn.className = 'level-btn';
            btn.textContent = `Level ${i}`;
            btn.onclick = () => loadLevel(i);
            container.appendChild(btn);
        }
    }

    async function loadLevel(level) {
        currentLevel = level;

        try {
            const res = await fetch(`/api/endgame/load/${level}`, {
                method: 'POST'
            });

            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }

            const data = await res.json();

            if(data.status === 'loaded') {
                document.getElementById('levelSelection').style.display = 'none';
                document.getElementById('gameArea').style.display = 'flex';

                initBoardFromData(data.board);
                resetGameState();
                draw();
            }
        } catch(err) {
            console.error('Failed to load level:', err);
            alert('Failed to load level: ' + err.message);
            useDefaultBoard();
        }
    }

    function backToLevels() {
        document.getElementById('gameArea').style.display = 'none';
        document.getElementById('levelSelection').style.display = 'block';
    }

    function resetLevel() {
        loadLevel(currentLevel);
    }

    /* ========== Use default board (fallback) ========== */
    function useDefaultBoard() {
        board = Array.from({length:ROWS}, ()=>Array(COLS).fill(null));
        board[9][4] = {s: RED, t: 'K'};
        board[8][0] = {s: RED, t: 'R'};
        board[0][4] = {s: BLACK, t: 'K'};

        resetGameState();
        draw();
    }

    /* ========== Board initialization ========== */
    function initBoardFromData(boardData) {
        board = Array.from({length:ROWS}, ()=>Array(COLS).fill(null));

        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                const cell = boardData[r][c];
                if(cell && cell.side && cell.type) {
                    board[r][c] = {
                        s: cell.side,
                        t: cell.type
                    };
                }
            }
        }
    }

    function resetGameState() {
        select = null;
        locked = false;
        foulRows = [];

        document.getElementById('foulTable').innerHTML = '<tr><th>#</th><th>Type</th></tr>';
        document.getElementById('statusBar').textContent = 'Status: In Progress';
        document.getElementById('statusBar').className = '';
    }

    /* ========== Drawing ========== */
    function drawPieces(){
        const size = Math.min(CELL_W, CELL_H) * 0.86, rds = size/2;
        for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){
            const p = board[r][c]; if(!p) continue;
            const x = INNER_X + c*CELL_W + CELL_W/2;
            const y = INNER_Y + r*CELL_H + CELL_H/2;
            const key = imgKeyOf(p), sp = IMGS[key];
            if(sp){
                ctx.drawImage(sp, x-rds, y-rds, size, size);
            } else {
                ctx.beginPath();
                ctx.arc(x,y,rds,0,Math.PI*2);
                ctx.fillStyle='#fff';
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = (p.s===RED)?'#c00':'#222';
                ctx.font='bold 20px system-ui';
                ctx.textAlign='center';
                ctx.textBaseline='middle';
                const glyph={K:'帅',A:'仕',B:'相',N:'马',R:'车',C:'炮',P:'兵'}[p.t]||'?';
                ctx.fillText(glyph,x,y);
            }
        }
    }

    function draw(){
        ctx.clearRect(0,0,OUT_W,OUT_H);
        if(IMGS.board){
            ctx.drawImage(IMGS.board, 0, 0, OUT_W, OUT_H);
        }
        if(select){
            ctx.fillStyle='rgba(0,128,255,.12)';
            ctx.fillRect(INNER_X + select.c*CELL_W, INNER_Y + select.r*CELL_H, CELL_W, CELL_H);
        }
        drawPieces();
    }

    /* ========== Click handling ========== */
    function hitToCell(x,y){
        const gx = x - INNER_X, gy = y - INNER_Y;
        if(gx < 0 || gy < 0 || gx > INNER_W || gy > INNER_H) return null;
        const c = Math.floor(gx / CELL_W);
        const r = Math.floor(gy / CELL_H);
        if(c<0||c>=COLS||r<0||r>=ROWS) return null;
        return {r,c};
    }

    cvs.addEventListener('click', async e=>{
        if (locked) return;
        const rect = cvs.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        const cell = hitToCell(x,y);
        if(!cell) return;

        const {r,c} = cell;
        if(!select){
            const p = board[r][c];
            if(p && p.s===RED){
                select={r,c};
                draw();
            }
            return;
        }else{
            const from = {...select};
            select = null;
            draw();
            if(from.r===r && from.c===c) return;
            await doMove(from.r, from.c, r, c);
        }
    });

    /* ========== Move logic ========== */
    function applyUci(uci){
        const fromC = uci.charCodeAt(0) - 97;
        const fromR = 9 - parseInt(uci[1],10);
        const toC   = uci.charCodeAt(2) - 97;
        const toR   = 9 - parseInt(uci[3],10);
        const p = board[fromR][fromC];
        if(!p) return;
        board[toR][toC] = p;
        board[fromR][fromC] = null;
    }

    function pushFoul(cnt, type = 'Illegal move') {
        document.getElementById('foulTable')
            .insertAdjacentHTML('beforeend', `<tr><td>${cnt}</td><td>${type}</td></tr>`);
        foulRows.push([cnt, type]);
    }

    async function doMove(fromR,fromC,toR,toC){
        try{
            const res = await fetch(`/api/endgame/move/${currentLevel}`,{
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body:JSON.stringify({fromR,fromC,toR,toC})
            });

            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }

            const data = await res.json();

            const bar = document.getElementById('statusBar');

            // Handle game end situations
            if(data.result === 'gameOver' || data.completed) {
                locked = true;

                // Update status bar
                bar.textContent = `Status: ${data.resultDescription}`;
                bar.className = 'game-over';

                if(data.resultDescription.includes('Congratulations')) {
                    bar.classList.add('win-message');
                } else {
                    bar.classList.add('lose-message');
                }

                // Apply final move and update board
                if (data.playerMove) {
                    applyUci(data.playerMove);
                }

                // Key: Use backend's latest board state to update frontend board
                if (data.board) {
                    initBoardFromData(data.board);
                }

                draw();

                // Only automatically download CSV file if there are foul records
                if (data.csvFilePath) {
                    // Automatically download CSV file
                    setTimeout(() => {
                        downloadCsvFile();
                    }, 500);
                }

                return;
            }

            if(data.result === 'foul'){
                pushFoul(data.foulCount, 'Illegal move');
                bar.textContent = `Status: Illegal move (${data.foulCount} fouls)`;
                // Ensure correct board state display
                if (data.board) {
                    initBoardFromData(data.board);
                    draw();
                }
                return;
            }

            // Normal move - use backend's board state to ensure synchronization
            if (data.board) {
                initBoardFromData(data.board);
            } else {
                // Fallback: update board using move logic
                if(data.playerMove) {
                    applyUci(data.playerMove);
                }
                if(data.aiMove) {
                    applyUci(data.aiMove);
                }
            }

            draw();

            // Update status information
            if(data.inCheck) {
                bar.textContent = 'Status: Check! Please escape check immediately';
            } else {
                bar.textContent = `Status: In Progress - ${data.turn === 'RED' ? 'Red' : 'Black'}'s turn`;
            }

        }catch(err){
            console.error('Move failed:', err);
            alert('Move failed: ' + err.message);
        }
    }

    /* ========== CSV automatic download ========== */
    async function downloadCsvFile() {
        try {
            const response = await fetch(`/api/endgame/download-csv/${currentLevel}`);
            if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;

                // Get filename from Content-Disposition header, or use default name
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = `endgame_${currentLevel}_fouls.csv`;
                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="(.+)"/);
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }

                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                console.log('CSV file automatically downloaded: ' + filename);
            } else {
                console.warn('CSV file not found or download failed');
            }
        } catch (error) {
            console.error('Automatic CSV download failed:', error);
        }
    }

    /* ========== Startup ========== */
    (async function(){
        await preload();
        initLevelSelection();
    })();
</script>
</body>
</html>